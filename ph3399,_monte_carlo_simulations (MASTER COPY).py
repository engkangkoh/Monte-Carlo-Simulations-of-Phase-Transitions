# -*- coding: utf-8 -*-
"""PH3399, Monte Carlo Simulations.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W8lE2DaU0uTTscDuk56z_gBqsiLksf_K
"""

# -*- coding: utf-8 -*-
"""
Created on Mon Feb 24 11:56:07 2020

@author: engkang
"""

#Import Needed library
import random
import numpy as np
import matplotlib.pyplot as plt
import math
k = 1                                                                           #boltzman constant equate to 1 for ease of simulation



#Creating random matrix that composed of equal 50-50 of 0 and 1 (Water and Oil)
def initgrid():
  matrix = np.random.randint(2, size=(10, 10))                                  #creating a 10 by 10 matrix abd filling it with 
  sum = np.sum(matrix)                                                          #sum up all values in matrix
  if sum == 50:                                                                 #making sure that the original matrix has 50 oil, 50 water
    return matrix
  else:
    return initgrid()                                                           #else rerun function



#Calculate Energy Values at each point
def add_index_energy(matrix,i,j):
  counter = 0
  
  def diff_value_abs(matrix,i,j,direction):
    if direction == "left":    
      return abs(matrix[i,j]-matrix[i-1,j])
    elif direction == "right":
      return abs(matrix[i,j]-matrix[i+1,j])
    elif direction == "up":
      return abs(matrix[i,j]-matrix[i,j+1])
    elif direction == "down":  
      return abs(matrix[i,j]-matrix[i,j-1])
    else:
      return "Error"
  #The function is created with general and special cases, the special cases is to analyze the function on every corner and the side of the box

  if i == 0: 
    if j == 0: #Case 1 : Corner Value (0,0)
      counter += abs(matrix[0,0]-matrix[0,1]) + abs(matrix[0,0]-matrix[1,0]) + abs(matrix[0,0]-matrix[9,0]) + abs(matrix[0,0]-matrix[9,9])
      return counter
    elif j == 9: #Case 2 : Corner Value (0,9)
      counter += abs(matrix[0,9]-matrix[0,8]) + abs(matrix[0,9]-matrix[1,9]) + abs(matrix[0,9]-matrix[0,0]) + abs(matrix[0,9]-matrix[9,9])
      return counter
    else: #Case 5 : Topmost Value (0,j)
      counter += abs(matrix[0,j]-matrix[9,j]) + abs(matrix[0,j]-matrix[1,j]) + abs(matrix[0,j]-matrix[0,j+1]) + abs(matrix[0,j]-matrix[0,j-1])
      return counter
  elif i == 9: #Case 3,4,8
    if j == 0: #Case 3 : Corner Value (9,0)
      counter += abs(matrix[9,0]-matrix[8,0]) + abs(matrix[9,0]-matrix[9,1]) + abs(matrix[9,0]-matrix[0,9]) + abs(matrix[9,0]-matrix[0,0])
      return counter
    if j == 9: #Case 4 : Corner Value (9,9)
      counter += abs(matrix[9,9]-matrix[9,0]) + abs(matrix[9,9]-matrix[0,9]) + abs(matrix[9,9]-matrix[9,8]) + abs(matrix[9,9]-matrix[8,9])
      return counter
    else: #Case 8 : Belowmost Value (9,j)
      counter += abs(matrix[9,j]-matrix[8,j]) + abs(matrix[9,j]-matrix[0,j]) + abs(matrix[9,j]-matrix[9,j+1]) + abs(matrix[9,j]-matrix[9,j-1])
      return counter
  elif j == 0: #Case 7
    #Case 7 : Letmost Value (i,0)
    counter += abs(matrix[i,0]-matrix[i-1,0]) + abs(matrix[i,0]-matrix[i+1,0]) + abs(matrix[i,0]-matrix[i,1]) + abs(matrix[i,0]-matrix[i,9])
    return counter
  elif j == 9: #Case 6
    #Case 6 : Rightmost Value (i,9)
    counter += abs(matrix[i,9]-matrix[i-1,9]) + abs(matrix[i,9]-matrix[i+1,9]) + abs(matrix[i,9]-matrix[i,0]) + abs(matrix[i,9]-matrix[i,8])
    return counter
  #The general cases is the adding function from the diff_value_abs(matrix,i,j,direction) which is iterative 
  else:
    counter += diff_value_abs(matrix,i,j,"left") + diff_value_abs(matrix,i,j,"right") + diff_value_abs(matrix,i,j,"up") +  diff_value_abs(matrix,i,j,"down") 
    return counter



#randomise 2 particles to swap
def swap(matrix_1):
  #Creating 2 random row and column for swapping
  rdm1 = random.randint(0,9)
  rdm2 = random.randint(0,9)
  rdm3 = random.randint(0,9)
  rdm4 = random.randint(0,9)
  #Creating 2 random row and column for swapping  
  if matrix_1[rdm1,rdm2] == 1 and matrix_1[rdm3,rdm4] == 0:
    store = matrix_1[rdm3,rdm4]
    matrix_1[rdm3,rdm4] = matrix_1[rdm1,rdm2]
    matrix_1[rdm1,rdm2] = store
    return matrix_1
  #Creating 2 random row and column for swapping  
  elif matrix_1[rdm1,rdm2] == 0 and matrix_1[rdm3,rdm4] == 1:
    store = matrix_1[rdm3,rdm4]
    matrix_1[rdm3,rdm4] = matrix_1[rdm1,rdm2]
    matrix_1[rdm1,rdm2] = store
    return matrix_1
    #Creating 2 random row and column for swapping
  else:
    return swap(matrix_1)



matrix_1 = initgrid()                                                           #matrix_1: POSITION OF WATER AND OIL

#matrix = matrix_energy

matrix_energy = np.zeros((10, 10))                                                     #create matrix of 0s
for i in range(10):
  for j in range(10):
      matrix_energy [i,j] = add_index_energy(matrix_1,i,j)                                    #matrix: INTERACTION ENERGY MATRIX DIAGRAM

print('50-50 Element State')
print(matrix_1)
print('\nEnergy State')
print(matrix_energy)
print(matrix_energy.sum())                                                             #calculate total energy

def add_index_density(matrix,i,j):
  counter = 0
  
  def local_density(matrix,i,j,direction):                                      #i,j is row,column
    if direction == "centre":
      return matrix[i,j]
    elif direction == "left":    
      return matrix[i,j-1]
    elif direction == "right":
      return matrix[i,j+1]
    elif direction == "up":
      return matrix[i-1,j]
    elif direction == "down":  
      return matrix[i+1,j]
    elif direction == "topleft":    
      return matrix[i-1,j-1]
    elif direction == "topright":    
      return matrix[i-1,j+1]
    elif direction == "bottomleft":    
      return matrix[i+1,j-1]
    elif direction == "bottomright":    
      return matrix[i+1,j+1]
    else:
      return "Error"
  #The function is created with general and special cases, the special cases is to analyze the function on every corner and the side of the box

  if i == 0: 
    if j == 0: #Case 1 : Corner Value (0,0)
      counter += matrix[0,0] + matrix[9,9] + matrix[0,9] + matrix[1,9] + matrix[9,0] + matrix[9,1] + matrix[1,0] + matrix[0,1] + matrix[1,1]
      return counter/9
    elif j == 9: #Case 2 : Corner Value (0,9)
      counter += matrix[0,9] + matrix[9,0] + matrix[9,9] + matrix[9,8] + matrix[0,0] + matrix[1,0] + matrix[0,8] + matrix[1,9] + matrix[1,8]
      return counter/9
    else: #Case 5 : Topmost Value (0,j)
      counter += matrix[0,j] + matrix[0,j-1] + matrix[0,j+1] + matrix[1,j] + matrix[1,j-1] + matrix[1,j+1] + matrix[9,j] + matrix[9,j+1] + matrix[9,j-1]
      return counter/9
  elif i == 9: #Case 3,4,8
    if j == 0: #Case 3 : Corner Value (9,0)
      counter += matrix[9,0] + matrix[0,9] + matrix[0,0] + matrix[0,1] + matrix[9,9] + matrix[8,9] + matrix[8,0] + matrix[8,1] + matrix[9,1]
      return counter/9
    if j == 9: #Case 4 : Corner Value (9,9)
      counter += matrix[9,9] + matrix[0,0] + matrix[8,0] + matrix[9,0] + matrix[0,8] + matrix[0,9] + matrix[8,8] + matrix[8,9] + matrix[9,8]
      return counter/9
    else: #Case 8 : Belowmost Value (9,j)
      counter += matrix[9,j] + matrix[9,j-1] + matrix[9,j+1] + matrix[8,j] + matrix[8,j-1] + matrix[8,j+1] + matrix[0,j] + matrix[0,j-1] + matrix[0,j+1]
      return counter/9
  elif j == 0: #Case 7
    #Case 7 : Letmost Value (i,0)
    counter += matrix[i,0] + matrix[i-1,0] + matrix[i+1,0] + matrix[i,9] + matrix[i-1,9] + matrix[i+1,9] + matrix[i,2] + matrix[i-1,2] + matrix[i+1,2]
    return counter/9
  elif j == 9: #Case 6
    #Case 6 : Rightmost Value (i,9)
    counter += matrix[i,9] + matrix[i-1,9] + matrix[i+1,9] + matrix[i,8] + matrix[i-1,8] + matrix[i+1,8] + matrix[i,0] + matrix[i-1,0] + matrix[i+1,0]
    return counter/9
  #The general cases is the adding function from the diff_value_abs(matrix,i,j,direction) which is iterative 
  else:
    counter += local_density(matrix,i,j,"left") + local_density(matrix,i,j,"right") + local_density(matrix,i,j,"up") +  local_density(matrix,i,j,"down") + local_density(matrix,i,j,"topleft") + local_density(matrix,i,j,"topright") + local_density(matrix,i,j,"bottomleft") +  local_density(matrix,i,j,"bottomright") + local_density(matrix,i,j,"centre")  
    return counter/9

matrix_density = np.zeros((10, 10))                                                     #create matrix of 0s
for i in range(10):
  for j in range(10):
      matrix_density [i,j] = add_index_density(matrix_1,i,j)                                    #matrix: INTERACTION ENERGY MATRIX DIAGRAM

print('50-50 Element State')
print(matrix_1)
print('\nLocal Density State')
print(matrix_density)
print('\nTotal Density:', matrix_density.sum())                                                             #calculate total energy

T = 4 #int(input('Please enter Temperature:'))                                #user input temperature


#condition for decreasing energy
def Emin_energy(T,matrix_1):
  matrix_1_temp = swap(matrix_1)
  matrix_energy_temp = np.zeros((10, 10))                                          #create matrix of 0s
  matrix_density_temp = np.zeros((10, 10)) 

  for i in range(10):
    for j in range(10):
      matrix_energy_temp [i,j] = add_index_energy(matrix_1_temp,i,j)                    #matrix_energy_new: NEW INTERATION ENERGY MATRIX AFTER SWAP
      matrix_density_temp [i,j] = add_index_density(matrix_1_temp,i,j)

  r = random.random()
  delE = matrix_energy_temp.sum()-matrix_energy.sum()                                     #delE: DIFFERENCE IN TOTAL ENERGY
  
  if matrix_energy_temp.sum() < matrix_energy.sum() or r < math.exp(-(delE)/(T)):
    matrix_1_new = matrix_1_temp
    matrix_energy_new = matrix_energy_temp
    matrix_density_new = matrix_density_temp
    
    print('50-50 Element State')
    print(matrix_1_new)
    print('\nNew Energy State')
    print(matrix_energy_new)

    print('\nNew Local Density State')
    print(matrix_density_new)
    print('\nNew Total Density:', matrix_density_new.sum())

    print(matrix_energy_new.sum())
    
    return matrix_1_new, matrix_energy_new, matrix_energy_new.sum(), matrix_density_new, matrix_density_new.sum()
  else:
    return Emin_energy(T,matrix_1)

# x = matrix_1_new, y = matrix_energy_new, z = matrix_energy_new.sum()

def recursive_energy(T,matrix_1_new):
  counter = 0
  energy = []
  density = []

  while counter < 1001 :
    print ("Trial No.: ", counter)
    matrix_1 = matrix_1_new
    Ty = matrix_energy.sum
    a,b,c,d,e = Emin_energy(T,matrix_1)
    energy.append(c)

    density.append(e)
    counter += 1
  # print(energy)
  return energy, matrix_1_new, density

energy, runfunc, density = recursive_energy(T,matrix_1)
print(runfunc)
print(energy)
print(density)

Tx = [i+1 for i in range(1001)]
Ty = energy

import numpy as np
print(np.average(energy))

plt.scatter(Tx,Ty)
plt.title('Relationship between Temperature and Total energy')
plt.xlabel('Number of Trial')
plt.ylabel('Energy')
plt.plot(Tx,Ty)
plt.show()

def temp_energy(matrix_1):
    energy_by_temp_list = []
    specific_heat = [] #1/T2 (energy^2)-ave_energy^2
    energy_fluctuation_list = [] #append for std
    density_list = []
    
    list_val = [(i+1)/10 for i in range(40)]
    
    for i in range(40):
        energy, runfunc, density = recursive_energy((i+1)/10,matrix_1)


        avg_total_density = np.average(density)
        density_list.append(avg_total_density)

        energy_fluctuation = np.std(energy)
        energy_fluctuation_list.append(energy_fluctuation)
        
        energy_by_temp = np.average(energy)
        energy_by_temp_list.append(energy_by_temp)
        
    energy_average = np.average(energy_by_temp_list)
    energy_square = (np.array(energy_by_temp_list))**2

    temp_val = np.array(list_val)
    
    specific_heat_array = (np.average(energy_square) - energy_average**2)/temp_val**2
    specific_heat = list(specific_heat_array)
    
    #The fluctuation : print(list_val[energy_fluctuation_list.index(max(energy_fluctuation_list))])
    
    return list_val, energy_by_temp_list, specific_heat, density_list, energy_fluctuation_list

x,y,z,a,b = temp_energy(matrix_1)

"""**Data Results**"""

plt.scatter(x,y)
plt.title('Relationship between Temperature and Total energy')
plt.xlabel('Temperature')
plt.ylabel('Energy')
plt.plot(x,y)
plt.savefig('energy_temp.png')
plt.show()

plt.scatter(x,z)
plt.title('Relationship between Specific Heat and Temperature')
plt.xlabel('Temperature')
plt.ylabel('Specific Heat')
plt.plot(x,z)
plt.savefig('specific_heat_temp.png')
plt.show()

plt.scatter(x,a)
plt.title('Relationship between Total Density and Temperature')
plt.xlabel('Temperature')
plt.ylabel('Total Density')
plt.plot(x,a)
plt.savefig('total_density_temp.png')
plt.show()

plt.scatter(x,b)
plt.title('Relationship between Energy Fluctuation and Temperature')
plt.xlabel('Temperature')
plt.ylabel('Energy Fluctuation')
plt.ylim((min(b)-0.5,max(b)+0.5))
plt.plot(x,b)
plt.savefig('energy_fluctuation_temp.png')
plt.show()